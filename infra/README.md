# Finance AI — Infrastructure (Terraform)

This folder (`/infra`) contains the **AWS IaC** for the Finance AI challenge.  
It deploys an HTTP API (API Gateway v2) with multiple **Lambda** functions (Node.js 20), a shared **Lambda Layer** (AWS SDK v3 for DynamoDB), a **DynamoDB** table (Provisioned 5/5 → free-tier friendly), an **SQS** queue for an async Advice worker (Bedrock), and **CloudWatch** logs with retention. A `$default` stage auto-deploys routes on API Gateway.

> **At a glance**
> - API: `GET /api/summary`, `GET /api/timeline`, `GET /api/advice/payload`, `GET /api/advice/status`, `POST /api/advice`
> - Data: `stori_challenge_transactions` (DynamoDB, PK=`pk`, SK=`sk`)
> - Async: SQS queue + Lambda worker (invokes **Bedrock** model)
> - Observability: CloudWatch log groups (Lambdas + API access logs)

---

## Architecture
```
[ Client / Frontend ] 
        |
        v
[ API Gateway (HTTP API v2, $default, CORS) ]
   ├── GET /api/summary     ──► [Lambda: summary]  ┐
   ├── GET /api/timeline    ──► [Lambda: timeline] ├─► [DynamoDB: stori_challenge_transactions]
   ├── GET /api/advice/payload ► [Lambda: advice_payload] │
   ├── GET /api/advice/status  ► [Lambda: advice_status]  │
   └── POST /api/advice        ► [Lambda: advice_request] ┘
                                    │
                                    ▼
                               [ SQS: advice-q ]
                                    │ (event source mapping)
                                    ▼
                             [ Lambda: advice_worker ]
                                    │
                                    ▼
                           [ Bedrock: InvokeModel* ]

```

- **Least privilege split**: general Lambdas use `lambda_exec`; advice-related functions use `lambda_exec_advice` with scoped policies (SQS + Bedrock invoke).
- **Shared deps**: a **Lambda Layer** bundles `@aws-sdk/*` for DynamoDB.
- **Code reuse**: `null_resource.sync_shared` copies `/lambdas/_shared` to each function at build time.

---

## Layout
```
infra/
  main.tf                # All resources (API GW, Lambdas, SQS, DynamoDB, roles, logs)
  variables.tf           # Inputs (region, memory, timeouts, CORS, retention)
  outputs.tf             # API invoke URL, etc.
  versions.tf            # TF + provider constraints
  build/                 # Zips generated by archive_file (gitignored)
  lambdas/
    _shared/             # common helpers copied into each lambda at build
    summary/             # GET /api/summary (index.js exports handler)
    timeline/            # GET /api/timeline
    advice/              # GET payload / POST request / GET status / worker.js
  layers/
    dynamo/nodejs/       # package.json + lock for AWS SDK v3
  Makefile               # Dev workflow (up/test/down/logs)

```

---

## Prerequisites

- **Terraform** ≥ 1.7
- **AWS CLI** configured (defaults to profile `stori-mvp`, region `us-east-1`; override via `make` variables)
- Node/npm for packaging the layer (`npm ci` runs under `layers/dynamo/nodejs`)

---

## Quick start

```bash
cd infra

# 1) Initialize
make init

# 2) Plan & apply
make up
# (runs: plan -> apply -> outputs)

# 3) Smoke test the endpoints
make test

# 4) Tail logs (optional)
make logs-summary
make logs-timeline
make logs-advice
make logs-apigw

# 5) Destroy everything
make down
```
make uses:
 - AWS_PROFILE (default: stori-mvp)
 - AWS_DEFAULT_REGION (default: us-east-1)
 - Extra TF flags via TF_FLAGS='-var aws_region=us-east-2' etc.

---
## Key resources

API Gateway (HTTP API v2)

 - `$default` stage with auto-deploy
 - CORS: `allow_origins = var.cors_allowed_origins` (methods: GET, POST, OPTIONS)
 - Access logs enabled to `/aws/apigw/${local.name_prefix}` with a JSON format (requestId, status, integrationStatus, error fields, etc.)

Lambda functions (Node 20)
 - summary → GET /api/summary
 - timeline → GET /api/timeline
 - advice_payload → GET /api/advice/payload
 - advice_request → POST /api/advice (enqueues job to SQS)
 - advice_status → GET /api/advice/status
 - advice_worker → SQS trigger; invokes Bedrock with BEDROCK_MODEL_ID, BEDROCK_MAX_TOKENS, BEDROCK_TEMPERATURE

All business Lambdas receive:

```
TABLE_NAME = aws_dynamodb_table.stori_challenge.name
```

Advice-related Lambdas additionally receive SQS / Bedrock env vars as defined in `main.tf`.

---

## Lambda Layer
- `stori-dynamo-sdk`: packages `@aws-sdk/*` for DynamoDB to keep function zips small.
- Rebuilt when `layers/dynamo/nodejs/package-lock.json` hash changes.
  
## SQS
- `advice-q` (visibility 300s), policies for Send / Receive / Delete / GetAttributes
- Event source mapping to `advice_worker` (batch_size 1)

## DynamoDB
- `stori_challenge_transactions`
- Provisioned: `read_capacity = 5, write_capacity = 5` (fits free tier)
- Keys: pk (HASH), sk (RANGE)
- Deletion protection enabled (`deletion_protection_enabled = true`)

## IAM
- `lambda_exec` (general) + `lambda_exec_advice` (advice/SQS/Bedrock)
- Managed: `AWSLambdaBasicExecutionRole`
- Inline: table R/W (Scan/Query/Put/Update/Get/BatchWrite)
- Bedrock invoke policy (`bedrock:InvokeModel`, `bedrock:InvokeModelWithResponseStream`) – Resource = "*" for demo; restrict to specific model ARNs in production.

## CloudWatch Logs
- One log group per Lambda (retention: `var.log_retention_days`)
- API Gateway access log group

---

## Endpoints
 - GET /api/summary
 - GET /api/timeline?from=YYYY-MM-DD&to=YYYY-MM-DD
 - GET /api/advice/payload
 - GET /api/advice/status?id=<jobId>
 - POST /api/advice 
   - Body: { ... } (creates an async job on SQS; worker consumes and writes the result)

Output: Terraform prints the base invoke URL:
`http_api_invoke_url = https://xxxxxxxx.execute-api.us-east-1.amazonaws.com`

---

## Variables & Outputs (high level)
Common inputs (see `variables.tf` for defaults):
- `project_name` (used as `local.name_prefix`)
- `aws_region`
- `lambda_timeout_s`, `lambda_memory_mb`
- `log_retention_days`
- `cors_allowed_origins` (list)
Outputs:
- `http_api_invoke_url` (use it in the frontend as API base)

## Testing
- Automated unit tests for infrastructure are not included.
- Smoke testing is provided via `make test` (cURLs against live endpoints).
- Next steps: add a minimal `terratest` or `infracost/tfsec` in CI, and function-level tests (Jest) for the Lambdas.

---

## Developer workflow (Makefile)
- `make whoami` — Check current AWS identity
- `make up` — init → plan → apply → outputs
- `make test` — Smoke test all endpoints
- `make down` — destroy + clean plan file
- `make logs-*` — Tail CloudWatch logs (summary/timeline/advice/apigw)

You can override:
```
make up AWS_PROFILE=my-profile REGION=us-east-2 TF_FLAGS='-var aws_region=us-east-2'
```

---

## Cost notes
 - API Gateway (HTTP API v2): low cost per request
 - Lambda: covered by the always-free 1M requests / 400k GB-s (per account)
 - DynamoDB: PROVISIONED 5/5 aligns with free tier
 - CloudWatch: small log ingestion + retention (configurable)

---

## Trade-offs & Improvements
- Pros: clear separation of concerns, least-privilege by function family, cheap to run, quick to iterate, logs & access logs enabled.
- Cons: single table, no VPC/private networking, Bedrock policy is wide (Resource="*"), DynamoDB deletion protection requires a manual step to destroy.
- Improvements: add auth (JWT/Cognito), restrict Bedrock resources, WAF in front of API, CI (fmt/validate/plan), S3 for build artifacts, per-function metric alarms/dashboards.